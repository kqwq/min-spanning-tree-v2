<!DOCTYPE html>
<html lang="en">

<head>
  <meta charset="UTF-8">
  <meta http-equiv="X-UA-Compatible" content="IE=edge">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>Min Spanning Tree</title>
  <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/bootstrap@4.6.1/dist/css/bootstrap.min.css"
    integrity="sha384-zCbKRCUGaJDkqS1kPbPd7TveP5iyJE0EjAuZQTgFLD2ylzuqKfdKlfG/eSrtxUkn" crossorigin="anonymous">
  <style>
    body {}

    canvas {
      /* horizontal centering */


      border: 1px solid black;
    }

    #step-list {
      height: 200px;
      overflow: auto;
    }

    .step-item {
      display: block;
      margin-right: 10px;
    }
  </style>


</head>

<body>

  <div id="main" class="container">

    <h1 class="mt-4">Min Spanning Tree</h1>
    <h2>Settings</h2>

    <!-- 
- Range slider for number of nodes
- Algorithm selection (Prim's / Boruvka's)

   -->
    <div class="row">
      <div class="col-md-6">
        <div class="form-group">
          <label for="numNodes">Number of Nodes</label>
          <input type="range" class="form-control-range" id="numNodes" min="2" max="100" value="10"
            oninput="updateNumNodes()">
          <b id="num-nodes">10</b>
        </div>
      </div>
      <div class="col-md-6">
        <div class="form-group">
          <label for="algorithm">Algorithm</label>
          <select class="form-control" id="algorithm" onchange="updateAlgorithm()">
            <option default value="">Select</option>
            <option value="prim">Prim's</option>
            <option value="boruvka">Boruvka's</option>
          </select>
        </div>
      </div>



    </div>
    <h2>Graph</h2>
    <div class="row">
      <canvas id="can"></canvas>

    </div>

    <div class="row">
      <h2>Steps</h2>
      <div class="col-md-12">
        <div class="height-50" id="step-list">
          <span class="step-item">Select an algorithm to begin</span>
        </div>
      </div>
    </div>



</body>
<script>
  const $ = x => document.querySelector(x);
  const $$ = x => document.querySelectorAll(x);

    // OOP stuff

  /**
   * @class Link
   * @param {Node} from
   * @param {Node} to
   * @param {number} age - from 0 to 1
   * 
   * Automatically adds nodes to each other's adjacency lists
   */
  class Link {
    constructor(from, to, age) {
      this.from = from;
      this.to = to;
      this.age = age;
      from.adj.push(to);
      to.adj.push(from);
      let r1 = from.r;
      let r2 = to.r;
      let chX = (to.x - from.x)
      let chY = (to.y - from.y)
      let dist = Math.sqrt(chX * chX + chY * chY)
      this.x1 = from.x + (r1 * chX) / dist
      this.y1 = from.y + (r1 * chY) / dist
      this.x2 = to.x - (r2 * chX) / dist
      this.y2 = to.y - (r2 * chY) / dist
    }
  }

  class Node {
    constructor(x, y, r, name) {
      this.x = x;
      this.y = y;
      this.r = r;
      this.name = name;
      this.adj = [];
    }
  }

  class Graph {
    constructor() {
      this.nodes = [];
      this.links = [];
      this.nameInd = 0;
    }
    removeAll() {
      this.nodes = [];
      this.links = [];
      this.nameInd = 0;
    }

    addNode(x, y, r) {
      let name = String.fromCharCode(65 + this.nameInd % 26) + ((this.nameInd > 26) ?
        Math.floor(this.nameInd / 26) : "");
      
      this.nameInd++;
      this.nodes.push(new Node(x, y, r, name));
    }

    addLink(node1, node2, age) {
      this.links.push(new Link(node1, node2, age));
    }
  }

  const canvas = $('#can');
  const ctx = canvas.getContext('2d');
  const graph = new Graph();
  const onResize = () => {
    // take up 90% of the screen
    canvas.width = window.innerWidth * 0.8;
    canvas.height = window.innerWidth / 2;
  }
  const update = () => {
    // bg
    ctx.fillStyle = '#111';
    ctx.fillRect(0, 0, canvas.width, canvas.height);

    
    // show links
    graph.links.forEach(link => {
        let hue = link.age * 360;
        ctx.strokeStyle = `hsl(${hue}, 100%, 50%)`;
        ctx.beginPath();
        ctx.moveTo(link.x1, link.y1);
        ctx.lineTo(link.x2, link.y2);
        ctx.stroke();
      
    });

    // show nodes
    ctx.fillStyle = '#444'; // node color
    ctx.strokeStyle = '#999'; // node border color
    graph.nodes.forEach(node => {
      ctx.beginPath();
      ctx.lineWidth = canvas.width / 400;
      ctx.arc(node.x, node.y, node.r, 0, 2 * Math.PI);
      ctx.fill();
      ctx.stroke();
    });

    // show name
    if (graph.nodes.length <= 26) {
      ctx.fillStyle = '#fff';
      ctx.font = '12px Arial';
      graph.nodes.forEach(node => {
        ctx.fillText(node.name, node.x - 5, node.y + 5);
      });
    } else {
      ctx.fillStyle = '#fff';
      ctx.font = '11px Arial';
      graph.nodes.forEach(node => {
        ctx.fillText(node.name, node.x + 5, node.y + 15);
      });
    }


    requestAnimationFrame(update);
  }
  const init = () => {
    onResize()
    update();
    updateNumNodes(10);

    // debug code links
    //graph.addLink(graph.nodes[0], graph.nodes[1]);
  }

  init()
  window.addEventListener('resize', onResize);

  function randRange(min, max) {
    return Math.random() * (max - min) + min;
  }

  function updateNumNodes(override) {
    const numNodes = override || $('#numNodes').value;
    $('#num-nodes').innerText = numNodes;
    graph.nodes = [];
    let k = 0.003;
    let nodeRadius = Math.sqrt(Math.pow(canvas.width, 2) * k / numNodes)
    graph.removeAll()
    for (let i = 0; i < numNodes; i++) {
      let x = randRange(nodeRadius, canvas.width - nodeRadius);
      let y = randRange(nodeRadius, canvas.height - nodeRadius);
      graph.addNode(x, y, nodeRadius);
    }
    
  generatePrimsAlgorithmSteps(graph)
  }

  function generatePrimsAlgorithmSteps(graph) {
    let steps = [];
    let edgeHistory = [];


    let R = [graph.nodes[0]]; // connected nodes
    let L = graph.nodes.slice(1); // to be connected nodes
    while (L.length > 0) {
      let bestDistSq = Infinity;
      let bestEdge = null;
      for (let r of R) {
        for (let l of L) {
          if (r == l) continue;
          let distSq = Math.pow(r.x - l.x, 2) + Math.pow(r.y - l.y, 2);
          if (distSq < bestDistSq) {
            bestDistSq = distSq;
            bestEdge = [r, l];
          }
        }
      }
      edgeHistory.push(bestEdge);
      R.push(bestEdge[1]);
      L.splice(L.indexOf(bestEdge[1]), 1);
      let prettyDist = Math.sqrt(bestDistSq).toFixed(2);
      steps.push(`Select edge ${bestEdge[0].name} - ${bestEdge[1].name} with a distance of ${prettyDist}`);
      let age = ((R.length-2) / graph.nodes.length) * 0.9;
      console.log(age)
      graph.addLink(bestEdge[0], bestEdge[1], age)
    }



    // Populate steps into the step list
    const stepList = $('#step-list');
    stepList.innerHTML = '';
    steps.forEach(step => {
      const stepItem = document.createElement('span');
      stepItem.classList.add('step-item');
      stepItem.innerText = step;
      stepList.appendChild(stepItem);
    });

  }

</script>

</html>